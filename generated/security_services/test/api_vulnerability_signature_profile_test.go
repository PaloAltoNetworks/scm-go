/*
 * Security Services Testing
 *
 * VulnerabilityProtectionSignaturesAPIService - Complete Create Test
 */

package security_services

import (
	"context"
	"fmt"
	"testing"

	"math/rand"
	"strconv"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/paloaltonetworks/scm-go/common"
	"github.com/paloaltonetworks/scm-go/generated/security_services"
)

// Threat ID Range
const (
	minA = 41000
	maxA = 45000
	minB = 6800001
	maxB = 6900000
)

// GenerateThreatIDString generates a Random Threat ID within the defined range: ([41000, 45000] OR [6800001, 6900000]).
func generateThreatIDString() string {
	var min, max int

	// Select Range A (41000 to 45000) or Range B (6800001 to 6900000).
	if rand.Intn(2) == 0 {
		min, max = minA, maxA
	} else {
		min, max = minB, maxB
	}

	rangeSize := max - min + 1
	id := min + rand.Intn(rangeSize)
	return strconv.Itoa(id)
}

// createSignatureBlock is a helper function for creating a Vulnerability Protection Signature.
func createSignatureBlock() *security_services.VulnerabilityProtectionSignaturesSignature {
	/*
		// --- Qualifiers ---
		qB1 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperatorGreaterThanQualifierInner{
			Name:  common.StringPtr("Q1"),
			Value: common.StringPtr("123"),
		}
		qB2 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperatorGreaterThanQualifierInner{
			Name:  common.StringPtr("Q2"),
			Value: common.StringPtr("456"),
		}
		qB3 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperatorEqualToQualifierInner{
			Name:  common.StringPtr("Q3"),
			Value: common.StringPtr("789"),
		}
	*/

	// --- Operators ---
	opA1LessThan := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperatorLessThan{
		Context: common.StringPtr("telnet-req-client-data"),
		Value:   common.Int32Ptr(123),
	}
	opB1GreaterThan := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperatorGreaterThan{
		Context: common.StringPtr("cip-ethernet-ip-req-class-id"),
		Value:   common.Int32Ptr(111111),
		//Qualifier: []security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperatorGreaterThanQualifierInner{qB1, qB2},
	}
	opB2EqualTo := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperatorEqualTo{
		Context: common.StringPtr("icmp-rsp-type"),
		Value:   common.Int32Ptr(222222),
		//Qualifier: []security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperatorEqualToQualifierInner{qB3},
	}
	opC1PatternMatch := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperatorPatternMatch{
		Context: common.StringPtr("dns-req-section"),
		Pattern: common.StringPtr("1200"),
		Negate:  common.BoolPtr(true),
	}

	//  --- OR Conditions ---
	orA1 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInner{
		Name: common.StringPtr("pattern-A1-" + common.GenerateRandomString(6)),
		Operator: &security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperator{
			LessThan: &opA1LessThan,
		},
	}
	orB1 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInner{
		Name: common.StringPtr("pattern-B1-" + common.GenerateRandomString(6)),
		Operator: &security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperator{
			GreaterThan: &opB1GreaterThan,
		},
	}
	orB2 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInner{
		Name: common.StringPtr("pattern-B2-" + common.GenerateRandomString(6)),
		Operator: &security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperator{
			EqualTo: &opB2EqualTo,
		},
	}
	orC1 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInner{
		Name: common.StringPtr("pattern-C1-" + common.GenerateRandomString(6)),
		Operator: &security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInnerOperator{
			PatternMatch: &opC1PatternMatch,
		},
	}

	// --- AND Conditions ---
	andA := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInner{
		Name:        common.StringPtr("condition-A-or-" + common.GenerateRandomString(6)),
		OrCondition: []security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInner{orA1},
	}
	andB := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInner{
		Name:        common.StringPtr("condition-B-or-" + common.GenerateRandomString(6)),
		OrCondition: []security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInner{orB1, orB2},
	}
	andC := security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInner{
		Name:        common.StringPtr("condition-C-or-" + common.GenerateRandomString(6)),
		OrCondition: []security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInnerOrConditionInner{orC1},
	}

	// --- Standard Inner Rules ---
	standard1 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInner{
		Name: "basic-signature-" + common.GenerateRandomString(6),
	}
	standard2 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInner{
		Name:         "standard-signature-one-" + common.GenerateRandomString(6),
		Scope:        common.StringPtr("protocol-data-unit"),
		OrderFree:    common.BoolPtr(false),
		AndCondition: []security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInner{andA},
	}
	standard3 := security_services.VulnerabilityProtectionSignaturesSignatureStandardInner{
		Name:         "standard-signature-two-" + common.GenerateRandomString(6),
		Scope:        common.StringPtr("session"),
		OrderFree:    common.BoolPtr(true),
		AndCondition: []security_services.VulnerabilityProtectionSignaturesSignatureStandardInnerAndConditionInner{andB, andC},
	}

	// --- Signature Block ---
	return &security_services.VulnerabilityProtectionSignaturesSignature{
		Standard: []security_services.VulnerabilityProtectionSignaturesSignatureStandardInner{standard1, standard2, standard3},
		// Combination: nil is fine if not required, otherwise provide:
		// Combination: &security_services.VulnerabilityProtectionSignaturesSignatureCombination{},
	}
}

// Test_security_services_VulnerabilityProtectionSignaturesAPIService_Create tests the creation of a Vulnerability Protection Signature.
func Test_security_services_VulnerabilityProtectionSignaturesAPIService_Create(t *testing.T) {
	client := SetupSecuritySvcTestClient(t)
	createdSignatureName := "test-vuln-sig-full-create-" + common.GenerateRandomString(6)

	testSignatureBlock := createSignatureBlock()

	signaturePayload := security_services.VulnerabilityProtectionSignatures{
		Folder:     common.StringPtr("Shared"),
		Threatname: createdSignatureName,
		ThreatId:   generateThreatIDString(),
		Severity:   common.StringPtr("high"),
		Direction:  common.StringPtr("client2server"),
		AffectedHost: &security_services.VulnerabilityProtectionSignaturesAffectedHost{
			Client: common.BoolPtr(true),
		},
		Bugtraq:   []string{"1555", "2555"},
		Reference: []string{"https://example.com/exploit-details"},
		Vendor:    []string{"Custom Vendor"},
		Comment:   common.StringPtr("Test Vulnerability Protection Signature for create API"),
		Cve:       []string{"CVE-2008-1147", "CVE-2012-1999"},
		DefaultAction: &security_services.VulnerabilityProtectionSignaturesDefaultAction{
			Allow: map[string]interface{}{},
		},
		Signature: testSignatureBlock,
	}

	fmt.Printf("Creating detailed Vulnerability Protection Signature with name: %s\n", signaturePayload.Threatname)
	req := client.VulnerabilityProtectionSignaturesAPI.CreateVulnerabilityProtectionSignatures(context.Background()).VulnerabilityProtectionSignatures(signaturePayload)
	res, httpRes, err := req.Execute()
	if err != nil {
		handleAPIError(err)
	}

	// --- Assertions and Cleanup ---
	require.NoError(t, err, "Failed to create Vulnerability Protection Signature")
	assert.Equal(t, 201, httpRes.StatusCode, "Expected 201 Created status")
	require.NotNil(t, res, "Response should not be nil")
	assert.Equal(t, createdSignatureName, res.Threatname, "Created signature name should match")
	createdSignatureID := *res.Id

	defer func() {
		t.Logf("Cleaning up Vulnerability Protection Signature with ID: %s", createdSignatureID)
		_, errDel := client.VulnerabilityProtectionSignaturesAPI.DeleteVulnerabilityProtectionSignaturesByID(context.Background(), createdSignatureID).Execute()
		require.NoError(t, errDel, "Failed to delete Vulnerability Protection Signature during cleanup")
	}()

	t.Logf("Successfully created detailed Vulnerability Protection Signature: %s with ID: %s", signaturePayload.Threatname, createdSignatureID)
}

// Test_security_services_VulnerabilityProtectionSignaturesAPIService_GetByID tests retrieving a Vulnerability Protection Signature by its ID.
func Test_security_services_VulnerabilityProtectionSignaturesAPIService_GetByID(t *testing.T) {
	client := SetupSecuritySvcTestClient(t)
	signatureName := "test-vuln-sig-get-" + common.GenerateRandomString(6)

	testSignatureBlock := createSignatureBlock()

	signaturePayload := security_services.VulnerabilityProtectionSignatures{
		Folder:     common.StringPtr("Shared"),
		Threatname: signatureName,
		ThreatId:   generateThreatIDString(),
		Severity:   common.StringPtr("low"),
		Direction:  common.StringPtr("server2client"),
		AffectedHost: &security_services.VulnerabilityProtectionSignaturesAffectedHost{
			Client: common.BoolPtr(true),
		},
		Signature: testSignatureBlock,
	}

	createRes, _, err := client.VulnerabilityProtectionSignaturesAPI.CreateVulnerabilityProtectionSignatures(context.Background()).VulnerabilityProtectionSignatures(signaturePayload).Execute()
	require.NoError(t, err, "Failed to create Vulnerability Protection Signature for get test")
	createdSignatureID := *createRes.Id
	require.NotEmpty(t, createdSignatureID, "Created signature ID should not be empty")

	// The rest of the original test logic: cleanup and GET request
	defer func() {
		t.Logf("Cleaning up Vulnerability Protection Signature with ID: %s", createdSignatureID)
		_, errDel := client.VulnerabilityProtectionSignaturesAPI.DeleteVulnerabilityProtectionSignaturesByID(context.Background(), createdSignatureID).Execute()
		require.NoError(t, errDel, "Failed to delete Vulnerability Protection Signature during cleanup")
	}()

	getRes, httpResGet, errGet := client.VulnerabilityProtectionSignaturesAPI.GetVulnerabilityProtectionSignaturesByID(context.Background(), createdSignatureID).Execute()
	require.NoError(t, errGet, "Failed to get Vulnerability Protection Signature by ID")
	assert.Equal(t, 200, httpResGet.StatusCode, "Expected 200 OK status")
	require.NotNil(t, getRes, "Get response should not be nil")
	assert.Equal(t, signatureName, getRes.Threatname, "Signature name should match")
}

// Test_security_services_VulnerabilityProtectionSignaturesAPIService_Update tests updating an existing Vulnerability Protection Signature.
func Test_security_services_VulnerabilityProtectionSignaturesAPIService_Update(t *testing.T) {
	client := SetupSecuritySvcTestClient(t)
	signatureName := "test-vuln-sig-update-" + common.GenerateRandomString(6)

	testSignatureBlock := createSignatureBlock()

	signaturePayload := security_services.VulnerabilityProtectionSignatures{
		Folder:     common.StringPtr("Shared"),
		Threatname: signatureName,
		ThreatId:   generateThreatIDString(),
		Severity:   common.StringPtr("low"),
		Direction:  common.StringPtr("server2client"),
		AffectedHost: &security_services.VulnerabilityProtectionSignaturesAffectedHost{
			Client: common.BoolPtr(true),
		},
		Signature: testSignatureBlock,
	}

	createRes, _, err := client.VulnerabilityProtectionSignaturesAPI.CreateVulnerabilityProtectionSignatures(context.Background()).VulnerabilityProtectionSignatures(signaturePayload).Execute()
	require.NoError(t, err, "Failed to create Vulnerability Protection Signature for update test")
	createdSignatureID := *createRes.Id
	require.NotEmpty(t, createdSignatureID, "Created signature ID should not be empty")

	defer func() {
		t.Logf("Cleaning up Vulnerability Protection Signature with ID: %s", createdSignatureID)
		_, errDel := client.VulnerabilityProtectionSignaturesAPI.DeleteVulnerabilityProtectionSignaturesByID(context.Background(), createdSignatureID).Execute()
		require.NoError(t, errDel, "Failed to delete Vulnerability Protection Signature during cleanup")
	}()

	updatedComment := "Updated vulnerability signature comment by automation test"
	updatedSignature := signaturePayload
	updatedSignature.Comment = common.StringPtr(updatedComment)

	updateRes, httpResUpdate, errUpdate := client.VulnerabilityProtectionSignaturesAPI.UpdateVulnerabilityProtectionSignaturesByID(context.Background(), createdSignatureID).VulnerabilityProtectionSignatures(updatedSignature).Execute()
	require.NoError(t, errUpdate, "Failed to update Vulnerability Protection Signature")
	assert.Equal(t, 200, httpResUpdate.StatusCode, "Expected 200 OK status")
	require.NotNil(t, updateRes, "Update response should not be nil")
	assert.Equal(t, updatedComment, *updateRes.Comment, "Comment should be updated")
}

/*
// Test_security_services_VulnerabilityProtectionSignaturesAPIService_List tests listing Vulnerability Protection Signatures.
func Test_security_services_VulnerabilityProtectionSignaturesAPIService_List(t *testing.T) {
	client := SetupSecuritySvcTestClient(t)
	signatureName := "test-vuln-sig-update-" + common.GenerateRandomString(6)

	testSignatureBlock := createSignatureBlock()

	signaturePayload := security_services.VulnerabilityProtectionSignatures{
		Folder:     common.StringPtr("Shared"),
		Threatname: signatureName,
		ThreatId:   generateThreatIDString(),
		Severity:   common.StringPtr("low"),
		Direction:  common.StringPtr("server2client"),
		AffectedHost: &security_services.VulnerabilityProtectionSignaturesAffectedHost{
			Client: common.BoolPtr(true),
		},
		Signature: testSignatureBlock,
	}

	createRes, _, err := client.VulnerabilityProtectionSignaturesAPI.CreateVulnerabilityProtectionSignatures(context.Background()).VulnerabilityProtectionSignatures(signaturePayload).Execute()
	require.NoError(t, err, "Failed to create Vulnerability Protection Signature for list test")
	createdSignatureID := *createRes.Id
	require.NotEmpty(t, createdSignatureID, "Created signature ID should not be empty")

	defer func() {
		t.Logf("Cleaning up Vulnerability Protection Signature with ID: %s", createdSignatureID)
		_, errDel := client.VulnerabilityProtectionSignaturesAPI.DeleteVulnerabilityProtectionSignaturesByID(context.Background(), createdSignatureID).Execute()
		require.NoError(t, errDel, "Failed to delete Vulnerability Protection Signature during cleanup")
	}()

	listRes, httpResList, errList := client.VulnerabilityProtectionSignaturesAPI.ListVulnerabilityProtectionSignatures(context.Background()).Folder("Shared").Limit(10000).Execute()
	require.NoError(t, errList, "Failed to list Vulnerability Protection Signatures")
	assert.Equal(t, 200, httpResList.StatusCode, "Expected 200 OK status")
	require.NotNil(t, listRes, "List response should not be nil")

	foundObject := false
	for _, s := range listRes.Data {
		if s.Threatname != "" && s.Threatname == signatureName {
			foundObject = true
			break
		}
	}
	assert.True(t, foundObject, "Created Vulnerability Protection Signature should be found in the list")
}
*/

// Test_security_services_VulnerabilityProtectionSignaturesAPIService_DeleteByID tests deleting a Vulnerability Protection Signature.
func Test_security_services_VulnerabilityProtectionSignaturesAPIService_DeleteByID(t *testing.T) {
	client := SetupSecuritySvcTestClient(t)
	signatureName := "test-vuln-sig-update-" + common.GenerateRandomString(6)

	testSignatureBlock := createSignatureBlock()

	signaturePayload := security_services.VulnerabilityProtectionSignatures{
		Folder:     common.StringPtr("Shared"),
		Threatname: signatureName,
		ThreatId:   generateThreatIDString(),
		Severity:   common.StringPtr("low"),
		Direction:  common.StringPtr("server2client"),
		AffectedHost: &security_services.VulnerabilityProtectionSignaturesAffectedHost{
			Client: common.BoolPtr(true),
		},
		Signature: testSignatureBlock,
	}

	createRes, _, err := client.VulnerabilityProtectionSignaturesAPI.CreateVulnerabilityProtectionSignatures(context.Background()).VulnerabilityProtectionSignatures(signaturePayload).Execute()
	require.NoError(t, err, "Failed to create Vulnerability Protection Signature for delete test")
	createdSignatureID := *createRes.Id
	require.NotEmpty(t, createdSignatureID, "Created signature ID should not be empty")

	httpResDel, errDel := client.VulnerabilityProtectionSignaturesAPI.DeleteVulnerabilityProtectionSignaturesByID(context.Background(), createdSignatureID).Execute()

	require.NoError(t, errDel, "Failed to delete Vulnerability Protection Signature")
	assert.Equal(t, 200, httpResDel.StatusCode, "Expected 200 OK status for delete")

	t.Logf("Successfully deleted signature with ID: %s", createdSignatureID)
}
